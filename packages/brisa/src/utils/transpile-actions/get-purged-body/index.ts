import type { ESTree } from 'meriyah';
import type { ActionInfo } from '@/utils/transpile-actions/get-actions-info';
import removeAllReturns from '@/utils/ast/remove-all-returns';
import containsIdentifiers from '@/utils/ast/contains-identifiers';
import getVarDeclarationIdentifiers from '@/utils/ast/get-var-declaration-identifiers';

/**
 * This process of purging the body is necessary to remove all the code
 * that is not necessary for the action to work. The action in a next
 * process is injected into the body and executed.
 *
 * The action needs the dependencies that only the action has, so the
 * rest of the code is purged.
 */
export function getPurgedBody(info: ActionInfo): ESTree.BlockStatement {
  const defaultBody = { type: 'BlockStatement', body: [] };
  const body = (info.componentFnExpression?.body ??
    defaultBody) as ESTree.BlockStatement;
  const bodyIdentifiers = getVarDeclarationIdentifiers(body);
  const actionFn =
    info.actionFnExpression ?? getActionFnFromActionIdentifier(info);
  const actionIdentifiers = getAllFunctionIdentifiers(
    body,
    actionFn as ESTree.Node,
  );
  const intersectionSet = new Set<string>();

  // Get the intersection of the identifiers between the action and the body
  // taking into account the dependencies of the identifiers.
  for (const [bodyIdentifier, deps] of bodyIdentifiers) {
    if (!actionIdentifiers.has(bodyIdentifier)) continue;
    intersectionSet.add(bodyIdentifier);
    for (const dep of deps) intersectionSet.add(dep);
  }

  return {
    ...body,
    // The [body] default value is necessary in cases that inside the
    // Component are elements generated by arrow functions without
    // block statements: const el = () => <div>hello</div>; return el();
    body: removeAllReturns(body.body ?? [body]).filter((node) => {
      return (
        (node as any).__isActionFn || containsIdentifiers(node, intersectionSet)
      );
    }),
  };
}

function getActionFnFromActionIdentifier(info: ActionInfo) {
  let actionFn:
    | ESTree.FunctionExpression
    | ESTree.ArrowFunctionExpression
    | undefined;

  JSON.stringify(info.componentFnExpression, (k, v) => {
    if (
      info.actionIdentifierName &&
      info.actionIdentifierName === v?.id?.name
    ) {
      v.__isActionFn = true;
      actionFn = v;
    }
    return v;
  });

  return actionFn;
}

export function getAllFunctionIdentifiers(
  node: ESTree.Node | undefined,
  fnNode: ESTree.Node,
): Set<string> {
  const callExpressions = new Set<string>();
  let identifiers = new Set<string>();

  if (!node) return identifiers;

  JSON.stringify(fnNode, (k, v) => {
    if (v?.type === 'Identifier') {
      identifiers.add(v.name);
    }

    if (v?.type === 'CallExpression') {
      callExpressions.add(v.callee.name);
      identifiers.add(v.callee.name);
    }

    return v;
  });

  if (callExpressions.size > 0) {
    JSON.stringify(node, (k, v) => {
      // This helper is used for (non-arrow) functions
      // (they are already transformed from arrow to function)
      if (v?.type === 'FunctionDeclaration' && callExpressions.has(v.id.name)) {
        identifiers = identifiers.union(getAllFunctionIdentifiers(node, v));
        return null;
      }

      return v;
    });
  }

  return identifiers;
}
